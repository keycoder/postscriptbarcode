%!PS

/setpacking where {pop currentpacking true setpacking} if
1 dict
dup /renmatrix dup /uk.co.terryburton.bwipp findresource put
begin
/qrcode {

    20 dict begin

    /options exch def
    /barcode exch def

    /dontdraw false def
    /format (full) def     % full or micro
    /version (unset) def
    /eclevel (unset) def   % L, M, Q or H
    /encoding (unset) def
    /raw false def
    /parse false def

    % Parse the input options
    options type /stringtype eq {
        1 dict begin
        options {
            token false eq {exit} if dup length string cvs (=) search
            true eq {cvlit exch pop exch def} {cvlit true def} ifelse
        } loop
        currentdict end /options exch def
    } if
    options {def} forall

    % Parse ordinals of the form ^NNN to ASCII
    parse {
        /msg barcode length string def
        /j 0 def
        barcode
        { % loop
            (^) search {
                dup msg exch j exch putinterval
                length j add 1 add /j exch def
                pop
                dup 0 3 getinterval cvi msg exch j 1 sub exch put
                dup length 3 sub 3 exch getinterval
            } {
                dup msg exch j exch putinterval
                length j add /j exch def
                /barcode msg 0 j getinterval def
                exit
            } ifelse 
        } loop
    } if

    /barlen barcode length def

    % Default error correction level
    eclevel (unset) eq {/eclevel format (full) eq {(M)} {(L)} ifelse def} if

    % Convert from input into message bitstream
    raw {/encoding (raw) def} if
    encoding (raw) eq {
        /msgbits barcode def 
    } {

        % Symbol capacities
        /fullcaps <<
            /numeric <<
                /L [   41    77   127   187   255   322   370   461   552   652    %  1-L - 10-L
                      772   883  1022  1101  1250  1408  1548  1725  1903  2061    % 11-L - 20-L
                     2232  2409  2620  2812  3057  3283  3517  3669  3909  4158    % 21-L - 30-L
                     4417  4686  4965  5253  5529  5836  6153  6479  6743  7089 ]  % 31-L - 40-L
                /M [   34    63   101   149   202   255   293   365   432   513    %  1-M - 10-M
                      604   691   796   871   991  1082  1212  1346  1500  1600    % 11-M - 20-M
                     1708  1872  2059  2188  2395  2544  2701  2857  3035  3289    % 21-M - 30-M
                     3486  3693  3909  4134  4343  4588  4775  5039  5313  5596 ]  % 31-M - 40-M
                /Q [   27    48    77   111   144   178   207   259   312   364    %  1-Q - 10-Q
                      427   489   580   621   703   775   876   948  1063  1159    % 11-Q - 20-Q
                     1224  1358  1468  1588  1718  1804  1933  2085  2181  2358    % 21-Q - 30-Q
                     2473  2670  2805  2949  3081  3244  3417  3599  3791  3993 ]  % 31-Q - 40-Q
                /H [   17    34    58    82   106   139   154   202   235   288    %  1-H - 10-H
                      331   374   427   468   530   602   674   746   813   919    % 11-H - 20-H
                      969  1056  1108  1228  1286  1425  1501  1581  1677  1782    % 21-H - 30-H
                     1897  2022  2157  2301  2361  2524  2625  2735  2927  3057 ]  % 31-H - 40-H
            >>
            /alphanumeric <<
                /L [   25    47    77   114   154   195   224   279   335   395    %  1-L - 10-L
                      468   535   619   667   758   854   938  1046  1153  1249    % 11-L - 20-L
                     1352  1460  1588  1704  1853  1990  2132  2223  2369  2520    % 21-L - 30-L
                     2677  2840  3009  3183  3351  3537  3729  3927  4087  4296 ]  % 31-L - 40-L
                /M [   20    38    61    90   122   154   178   221   262   311    %  1-M - 10-M
                      366   419   483   528   600   656   734   816   909   970    % 11-M - 20-M
                     1035  1134  1248  1326  1451  1542  1637  1732  1839  1994    % 21-M - 30-M
                     2113  2238  2369  2506  2632  2780  2894  3054  3220  3391 ]  % 31-M - 40-M
                /Q [   16    29    47    67    87   108   125   157   189   221    %  1-Q - 10-Q
                      259   296   352   376   426   470   531   574   644   702    % 11-Q - 20-Q
                      742   823   890   963  1041  1094  1172  1263  1322  1429    % 21-Q - 30-Q
                     1499  1618  1700  1787  1867  1966  2071  2181  2298  2420 ]  % 31-Q - 40-Q
                /H [   10    20    35    50    64    84    93   122   143   174    %  1-H - 10-H
                      200   227   259   283   321   365   408   452   493   557    % 11-H - 20-H
                      587   640   672   744   779   864   910   958  1016  1080    % 21-H - 30-H
                     1150  1226  1307  1394  1431  1530  1591  1658  1774  1852 ]  % 31-H - 40-H
            >>
            /byte <<
                /L [   17    32    53    78   106   134   154   192   230   271    %  1-L - 10-L
                      321   367   425   458   520   586   644   718   792   858    % 11-L - 20-L
                      929  1003  1091  1171  1273  1367  1465  1528  1628  1732    % 21-L - 30-L
                     1840  1952  2068  2188  2303  2431  2563  2699  2809  2953 ]  % 31-L - 40-L
                /M [   14    26    42    62    84   106   122   152   180   213    %  1-M - 10-M
                      251   287   331   362   412   450   504   560   624   666    % 11-M - 20-M
                      711   779   857   911   997  1059  1125  1190  1264  1370    % 21-M - 30-M
                     1452  1538  1628  1722  1809  1911  1989  2099  2213  2331 ]  % 31-M - 40-M
                /Q [   11    20    32    46    60    74    86   108   130   151    %  1-Q - 10-Q
                      177   203   241   258   292   322   364   394   442   482    % 11-Q - 20-Q
                      509   565   611   661   715   751   805   868   908   982    % 21-Q - 30-Q
                     1030  1112  1168  1228  1283  1351  1423  1499  1579  1663 ]  % 31-Q - 40-Q
                /H [    7    14    24    34    44    58    64    84    98   119    %  1-H - 10-H
                      137   155   177   194   220   250   280   310   338   382    % 11-H - 20-H
                      403   439   461   511   535   593   625   658   698   742    % 21-H - 30-H
                      790   842   898   958   983  1051  1093  1139  1219  1273 ]  % 31-H - 40-H
            >>
            /kanji <<
                /L [   10    20    32    48    65    82    95   118   141   167    %  1-L - 10-L
                      198   226   262   282   320   361   397   442   488   528    % 11-L - 20-L
                      572   618   672   721   784   842   902   940  1002  1066    % 21-L - 30-L
                     1132  1201  1273  1347  1417  1496  1577  1661  1729  1817 ]  % 31-L - 40-L
                /M [    8    16    26    38    52    65    75    93   111   131    %  1-M - 10-M
                      155   177   204   223   254   277   310   345   384   410    % 11-M - 20-M
                      438   480   528   561   614   652   692   732   778   843    % 21-M - 30-M
                      894   947  1002  1060  1113  1176  1224  1292  1362  1435 ]  % 31-M - 40-M
                /Q [    7    12    20    28    37    45    53    66    80    93    %  1-Q - 10-Q
                      109   125   149   159   180   198   224   243   272   297    % 11-Q - 20-Q
                      314   348   376   407   440   462   496   534   559   604    % 21-Q - 30-Q
                      634   684   719   756   790   832   876   923   972  1024 ]  % 31-Q - 40-Q
                /H [    4     8    15    21    27    36    39    52    60    74    %  1-H - 10-H
                       85    96   109   120   136   154   173   191   208   235    % 11-H - 20-H
                      248   270   284   315   330   365   385   405   430   457    % 21-H - 30-H
                      486   518   553   590   605   647   673   701   750   784 ]  % 31-H - 40-H 
            >> 
        >> def 

        %            M1 M2 M3 M4         M1 M2 M3 M4         M1 M2 M3 M4         M1 M2 M3 M4
        /microcaps <<
            /numeric <<
                /L [  5 10 23 35 ]  /M [ -1  8 18 30 ]  /Q [ -1 -1 -1 21 ]  /H [ -1 -1 -1 -1 ]
            >>
            /alphanumeric <<
                /L [ -1  6 14 21 ]  /M [ -1  5 11 18 ]  /Q [ -1 -1 -1 13 ]  /H [ -1 -1 -1 -1 ]
            >>
            /byte <<
                /L [ -1 -1  9 15 ]  /M [ -1 -1  7 13 ]  /Q [ -1 -1 -1  9 ]  /H [ -1 -1 -1 -1 ]
            >> 
            /kanji <<
                /L [ -1 -1  6  9 ]  /M [ -1 -1  4  8 ]  /Q [ -1 -1 -1  5 ]  /H [ -1 -1 -1 -1 ]
            >>
        >> def

        /encvals <<
            /numeric      0
            /alphanumeric 1
            /byte         2
            /kanji        3
        >> def

        /encs <<
            /numeric      /encnumeric
            /alphanumeric /encalphanumeric
            /byte         /encbyte
            /kanji        /enckanji
        >> def

        %           N      A      B      K
        /mids  [ (0001) (0010) (0100) (1000) ] def
        /mids <<
           /M1 [     ()     -1     -1     -1 ]
           /M2 [    (0)    (1)     -1     -1 ]
           /M3 [   (00)   (01)   (10)   (11) ]
           /M4 [  (000)  (001)  (010)  (011) ]
           1 1 40 {2 string 10 exch cvrs mids} for
        >> def

        %            N  A  B  K
        /cc1to9   [ 10  9  8  8 ] def
        /cc10to26 [ 12 11 16 10 ] def
        /cc27to40 [ 14 13 16 12 ] def
        /cclens <<
            /M1   [  3 -1 -1 -1 ]
            /M2   [  4  3 -1 -1 ]
            /M3   [  5  4  4  3 ]
            /M4   [  6  5  5  4 ]
             1 1  9 { 2 string 10 exch cvrs cc1to9 } for
            10 1 26 { 2 string 10 exch cvrs cc10to26 } for            
            27 1 40 { 2 string 10 exch cvrs cc27to40 } for
        >> def

        % Alphanumeric character to value map
        /charmap (0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:) def
        /charvals 44 dict def
        0 1 44 {dup charmap exch get exch charvals 3 1 roll put} for

        /encnumeric {
            /in exch def
            /out in length 10 mul 3 idiv 1 add string def
            /i 0 def /j 0 def {
                i in length eq {exit} if
                i in length 2 sub lt {
                    (0000000000) 10 string copy
                    dup in i 3 getinterval cvi
                    2 10 string cvrs dup length 10 exch sub exch putinterval
                    /i i 3 add def
                } {
                    i in length 2 sub eq {  % Two final digits
                        (0000000) 7 string copy
                        dup in i 2 getinterval cvi
                        2 7 string cvrs dup length 7 exch sub exch putinterval
                        /i i 2 add def
                    } {  % One final digit
                        (0000) 4 string copy
                        dup in i 1 getinterval cvi
                        2 4 string cvrs dup length 4 exch sub exch putinterval
                        /i i 1 add def
                    } ifelse
                } ifelse
                dup out exch j exch putinterval
                length j add /j exch def
            } loop
            out 0 j getinterval
        } bind def

        /encalphanumeric {
            /in exch def
            /out in length 11 mul 2 idiv 1 add string def
            /i 0 def /j 0 def {
                i in length eq {exit} if
                i in length 1 sub lt {
                    (00000000000) 11 string copy
                    dup charvals in i get get 45 mul charvals in i 1 add get get add
                    2 11 string cvrs dup length 11 exch sub exch putinterval
                    /i i 2 add def
                } {
                    (000000) 6 string copy
                    dup charvals in i get get
                    2 6 string cvrs dup length 6 exch sub exch putinterval
                    /i i 1 add def
                } ifelse
                dup out exch j exch putinterval
                length j add /j exch def
            } loop
            out 0 j getinterval
        } bind def

        /encbyte {
            /in exch def
            /out in length 8 mul string def
            0 1 in length 1 sub {
                /i exch def
                (00000000) 8 string copy
                dup in i get cvi
                2 8 string cvrs dup length 8 exch sub exch putinterval 
                out i 8 mul 3 -1 roll putinterval
            } for
            out
        } bind def

        /enckanji {
            /in exch def
            /out in length 2 idiv 13 mul string def
            /i 0 def /j 0 def {
                i in length eq {exit} if
                in i get 256 mul in i 1 add get add
                dup 16#E040 lt {16#8140} {16#C140} ifelse sub
                dup -8 bitshift 16#C0 mul exch 16#00FF and add
                (0000000000000) 13 string copy
                dup 3 -1 roll 2 13 string cvrs dup length 13 exch sub exch putinterval
                dup out exch j exch putinterval
                length j add /j exch def
                /i i 2 add def
            } loop
            out
        } bind def

        % Determine a compact encoding for the data
        encoding (unset) eq {
            /numericokay true def
            /alphanumericokay true def
            /kanjiokay true def
            /byteokay true def
            barlen 2 mod 0 ne {/kanjiokay false def} if
            0 1 barlen 1 sub {
                /i exch def
                /barchar barcode i get def
                barchar 48 lt barchar 57 gt or {/numericokay false def} if
                charvals barchar known not {/alphanumericokay false def} if
                i 2 mod 0 eq {
                    barchar 16#81 lt barchar 16#9F gt or
                    barchar 16#E0 lt barchar 16#EB gt or and {
                        /kanjiokay false def
                    } if
                } if
            } for
            byteokay         {/encoding (byte) def} if
            kanjiokay        {/encoding (kanji) def} if
            alphanumericokay {/encoding (alphanumeric) def} if
            numericokay      {/encoding (numeric) def} if
        } if

        % Determine smallest symbol version to hold given amount of data
        /numchars barlen encoding (kanji) eq {2 idiv} if def
        version (unset) eq {
            /caps format (full) eq {fullcaps} {microcaps} ifelse encoding get eclevel get def
            /i 1 def {
                numchars caps i 1 sub get le {exit} if
                /i i 1 add def
            } loop
            /version i 10 2 string cvrs def
            format (micro) eq {
                /version (M ) 2 string copy dup version 1 exch putinterval def
            } if
        } if

        % Opportunistically raise the error correction level for a fit to the same symbol
        /caps format (full) eq {fullcaps} {microcaps} ifelse encoding get def
        /verval format (full) eq {version cvi 1 sub} {version 1 get 49 sub} ifelse def
        eclevel (L) eq {numchars caps /M get verval get le {/eclevel (M) def} if} if
        eclevel (M) eq {numchars caps /Q get verval get le {/eclevel (Q) def} if} if
        eclevel (Q) eq {numchars caps /H get verval get le {/eclevel (H) def} if} if

        % Set the control character data for the version
        /mid mids version get encvals encoding get get def
        /cclen cclens version get encvals encoding get get def
 
        % Create the bitstream as mode_id character_count encoded_data
        /enc barcode encs encoding get load exec def
        (0000000000000000) 0 cclen getinterval cclen string copy 
        dup barlen encoding (kanji) eq {2 idiv} if cvi
        2 cclen string cvrs dup length cclen exch sub exch putinterval 
        /cc exch def
        /msgbits mid length cclen add enc length add string def
        msgbits 0 mid putinterval
        msgbits mid length cc putinterval
        msgbits mid length cclen add enc putinterval

    } ifelse

    % Lookup the most appropriate symbol specification
    /metrics [
        % format   vers  size align modules    error codewords        error correction blocks 
        %                                      L    M    Q    H       L1 L2 M1 M2 Q1 Q2 H1 H2
        [ (micro)  (M1)   11  98 99     36  [   2   99   99   99 ]  [  1  0 -1 -1 -1 -1 -1 -1 ] ]
        [ (micro)  (M2)   13  98 99     80  [   5    6   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M3)   15  98 99    132  [   6    8   99   99 ]  [  1  0  1  0 -1 -1 -1 -1 ] ]
        [ (micro)  (M4)   17  98 99    192  [   8   10   14   99 ]  [  1  0  1  0  1  0 -1 -1 ] ]
        [ (full)   (1)    21  98 99    208  [   7   10   13   17 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (2)    25  18 99    359  [  10   16   22   28 ]  [  1  0  1  0  1  0  1  0 ] ]
        [ (full)   (3)    29  22 99    567  [  15   26   36   44 ]  [  1  0  1  0  2  0  2  0 ] ]
        [ (full)   (4)    33  26 99    807  [  20   36   52   64 ]  [  1  0  2  0  2  0  4  0 ] ]
        [ (full)   (5)    37  30 99   1079  [  26   48   72   88 ]  [  1  0  2  0  2  2  2  2 ] ]
        [ (full)   (6)    41  34 99   1383  [  36   64   96  112 ]  [  2  0  4  0  4  0  4  0 ] ]
        [ (full)   (7)    45  22 38   1568  [  40   72  108  130 ]  [  2  0  4  0  2  4  4  1 ] ]
        [ (full)   (8)    49  24 42   1936  [  48   88  132  156 ]  [  2  0  2  2  4  2  4  2 ] ]
        [ (full)   (9)    53  26 46   2336  [  60  110  160  192 ]  [  2  0  3  2  4  4  4  4 ] ]
        [ (full)   (10)   57  28 50   2768  [  72  130  192  224 ]  [  2  2  4  1  6  2  6  2 ] ]
        [ (full)   (11)   61  30 54   3232  [  80  150  224  264 ]  [  4  0  1  4  4  4  3  8 ] ]
        [ (full)   (12)   65  32 58   3728  [  96  176  260  308 ]  [  2  2  6  2  4  6  7  4 ] ]
        [ (full)   (13)   69  34 62   4256  [ 104  198  288  352 ]  [  4  0  8  1  8  4 12  4 ] ]
        [ (full)   (14)   73  26 46   4651  [ 120  216  320  384 ]  [  3  1  4  5 11  5 11  5 ] ]
        [ (full)   (15)   77  26 48   5243  [ 132  240  360  432 ]  [  5  1  5  5  5  7 11  7 ] ]
        [ (full)   (16)   81  26 50   5867  [ 144  280  408  480 ]  [  5  1  7  3 15  2  3 13 ] ]
        [ (full)   (17)   85  30 54   6523  [ 168  308  448  532 ]  [  1  5 10  1  1 15  2 17 ] ]
        [ (full)   (18)   89  30 56   7211  [ 180  338  504  588 ]  [  5  1  9  4 17  1  2 19 ] ]
        [ (full)   (19)   93  30 58   7931  [ 196  364  546  650 ]  [  3  4  3 11 17  4  9 16 ] ]
        [ (full)   (20)   97  34 62   8683  [ 224  416  600  700 ]  [  3  5  3 13 15  5 15 10 ] ]
        [ (full)   (21)  101  28 50   9252  [ 224  442  644  750 ]  [  4  4 17  0 17  6 19  6 ] ]
        [ (full)   (22)  105  26 50  10068  [ 252  476  690  816 ]  [  2  7 17  0  7 16 34  0 ] ]
        [ (full)   (23)  109  30 54  10916  [ 270  504  750  900 ]  [  4  5  4 14 11 14 16 14 ] ]
        [ (full)   (24)  113  28 54  11796  [ 300  560  810  960 ]  [  6  4  6 14 11 16 30  2 ] ]
        [ (full)   (25)  117  32 58  12708  [ 312  588  870 1050 ]  [  8  4  8 13  7 22 22 13 ] ]
        [ (full)   (26)  121  30 58  13652  [ 336  644  952 1110 ]  [ 10  2 19  4 28  6 33  4 ] ]
        [ (full)   (27)  125  34 62  14628  [ 360  700 1020 1200 ]  [  8  4 22  3  8 26 12 28 ] ]
        [ (full)   (28)  129  26 50  15371  [ 390  728 1050 1260 ]  [  3 10  3 23  4 31 11 31 ] ]
        [ (full)   (29)  133  30 54  16411  [ 420  784 1140 1350 ]  [  7  7 21  7  1 37 19 26 ] ]
        [ (full)   (30)  137  26 52  17483  [ 450  812 1200 1440 ]  [  5 10 19 10 15 25 23 25 ] ]
        [ (full)   (31)  141  30 56  18587  [ 480  868 1290 1530 ]  [ 13  3  2 29 42  1 23 28 ] ]
        [ (full)   (32)  145  34 60  19723  [ 510  924 1350 1620 ]  [ 17  0 10 23 10 35 19 35 ] ]
        [ (full)   (33)  149  30 58  20891  [ 540  980 1440 1710 ]  [ 17  1 14 21 29 19 11 46 ] ]
        [ (full)   (34)  153  34 62  22091  [ 570 1036 1530 1800 ]  [ 13  6 14 23 44  7 59  1 ] ]
        [ (full)   (35)  157  30 54  23008  [ 570 1064 1590 1890 ]  [ 12  7 12 26 39 14 22 41 ] ]
        [ (full)   (36)  161  24 50  24272  [ 600 1120 1680 1980 ]  [  6 14  6 34 46 10  2 64 ] ]
        [ (full)   (37)  165  28 54  25568  [ 630 1204 1770 2100 ]  [ 17  4 29 14 49 10 24 46 ] ]
        [ (full)   (38)  169  32 58  26896  [ 660 1260 1860 2220 ]  [  4 18 13 32 48 14 42 32 ] ]
        [ (full)   (39)  173  26 54  28256  [ 720 1316 1950 2310 ]  [ 20  4 40  7 43 22 10 67 ] ]
        [ (full)   (40)  177  30 58  29648  [ 750 1372 2040 2430 ]  [ 19  6 18 31 34 34 20 61 ] ]
    ] def
    /eclval (LMQH) eclevel search pop length exch pop exch pop def
    /i 0 def
    { % loop
        /m metrics i get def
        /frmt m 0 get def                             % Format of the symbol
        /vers m 1 get def                             % Version of symbol
        /size m 2 get def                             % Length of side
        /asp2 m 3 get def                             % Position of second alignment symbol
        /asp3 m 4 get def                             % Position of third alignment symbol
        /nmod m 5 get def                             % Number of modules
        /ncws nmod 8 idiv def                         % Total number of codewords
        /rbit nmod 8 mod def                          % Number of remainder bits
        /lc4b false def                               % Last data codeword is 4 bits long
        size 11 eq size 15 eq or {                    % Adjustments for M1 and M3 symbols
            /ncws ncws 1 add def
            /rbit 0 def
            /lc4b true def
        } if
        /ecws m 6 get eclval get def                  % Number of error correction codewords
        /dcws ncws ecws sub def                       % Number of data codewords
        /dmod dcws 8 mul lc4b {4} {0} ifelse sub def  % Number of data modules
        /ecb1 m 7 get eclval 2 mul get def            % First error correction blocks
        /ecb2 m 7 get eclval 2 mul 1 add get def      % Second error correction blocks
        /okay true def
        format frmt ne {/okay false def} if           % The format must match that supplied
        version (unset) ne version vers ne and {/okay false def} if  % The version must match that supplied
        msgbits length dmod gt {/okay false def} if   % Bitstream must fit into data modules
        ecb1 -1 eq ecb2 -1 eq or {/okay false def} if % Error correction level must be valid
        okay {exit} if
        /i i 1 add def
    } loop

    /format frmt def
    /version vers def
    /dcpb dcws ecb1 ecb2 add idiv def                 % Base data codewords per block
    /ecpb ncws ecb1 ecb2 add idiv dcpb sub def        % Error correction codewords per block

    % Complete the message bits by adding the terminator, truncated if neccessary
    /terms <<
        /M1 (000)
        /M2 (00000)
        /M3 (0000000)
        /M4 (000000000)
    >> def
    /term terms version known {terms version get} {(0000)} ifelse def
    /term term 0 dmod msgbits length sub term length 2 copy gt {exch} if pop getinterval def
    msgbits length term length add string
    dup 0 msgbits putinterval
    dup msgbits length term putinterval
    /msgbits exch def
    
    % Expand the message bits by adding padding as necessary
    /pad dmod string def
    0 1 pad length 1 sub {pad exch 48 put} for
    pad 0 msgbits putinterval
    /padstrs [ (11101100) (00010001) ] def
    /padnum 0 def
    msgbits length 8 div ceiling 8 mul cvi 8 dmod lc4b {5} {1} ifelse sub {
        pad exch padstrs padnum get putinterval 
        /padnum padnum 1 add 2 mod def
    } for

    % Evaluate the padded message into codewords
    /cws dcws array def 
    0 1 cws length 1 sub {
        /c exch def
        /bpcw 8 def
        lc4b c cws length 1 sub eq and {/bpcw 4 def} if
        /cwb pad c 8 mul bpcw getinterval def
        /cw 0 def
        0 1 bpcw 1 sub {
            /i exch def
            /cw cw 2 bpcw i sub 1 sub exp cvi cwb i get 48 sub mul add def
        } for 
        cws c cw put
    } for 

    % Calculate the log and anti-log tables
    /rsalog [ 1 255 { dup 2 mul dup 256 ge {285 xor} if } repeat ] def
    /rslog 256 array def
    1 1 255 {dup rsalog exch get exch rslog 3 1 roll put} for

    % Function to calculate the product in the field
    /rsprod {
        2 copy 0 ne exch 0 ne and { 
            rslog exch get exch rslog exch get add 255 mod rsalog exch get
        } {
            pop pop 0
        } ifelse
    } bind def

    % Generate the coefficients for the Reed-Solomon algorithm
    /coeffs [ 1 ecpb {0} repeat ] def
    0 1 ecpb 1 sub {
        /i exch def 
        coeffs i 1 add coeffs i get put
        i -1 1 {
            /j exch def
            coeffs j coeffs j 1 sub get coeffs j get rsalog i get rsprod xor put
        } for 
        coeffs 0 coeffs 0 get rsalog i get rsprod put
    } for
    /coeffs coeffs 0 coeffs length 1 sub getinterval def

    % Reed-Solomon algorithm to derive the error correction codewords
    /rscodes {
        /rscws exch def
        /rsnd rscws length def
        /rscws [ rscws {} forall ecpb {0} repeat ] def
        0 1 rsnd 1 sub {
            /m exch def
            /k rscws m get def
            0 1 ecpb 1 sub {
                /j exch def
                rscws m j add 1 add coeffs ecpb j sub 1 sub get k rsprod rscws m j add 1 add get xor put
            } for
        } for
        rscws rsnd ecpb getinterval
    } bind def

    % Divide codewords into two groups of blocks and calculate the error correction codewords
    /dcwsb ecb1 ecb2 add array def
    /ecwsb ecb1 ecb2 add array def
    0 1 ecb1 1 sub {  % First group of blocks has smaller number of data codewords
        /i exch def
        dcwsb i cws i dcpb mul dcpb getinterval put
        ecwsb i dcwsb i get rscodes put
    } for
    0 1 ecb2 1 sub {  % Second group of blocks has larger number of data codewords
        /i exch def
        dcwsb ecb1 i add cws ecb1 dcpb mul i dcpb 1 add mul add dcpb 1 add getinterval put
        ecwsb ecb1 i add dcwsb ecb1 i add get rscodes put
    } for
    
    % Reassemble the codewords
    /cws ncws array def
    /cw 0 def
    0 1 dcpb {  % Interleave the data codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            i dcwsb j get length lt {  % Ignore the end of short blocks
                cws cw dcwsb j get i get put
                /cw cw 1 add def
            } if
        } for
    } for
    0 1 ecpb 1 sub {  % Interleave the error codeword blocks
        /i exch def
        0 1 ecb1 ecb2 add 1 sub {
            /j exch def
            cws cw ecwsb j get i get put
            /cw cw 1 add def
        } for
    } for
    
    % Extend codewords by one if there are remainder bits
    rbit 0 gt {
        /pad cws length 1 add array def
        pad 0 cws putinterval
        pad pad length 1 sub 0 put
        /cws pad def
    } if
 
    % Fixups for the short final data byte in M1 and M3 symbols
    lc4b {
        dcws 1 sub 1 ncws 2 sub {
            /i exch def
            cws i cws i get 15 and 4 bitshift put
            cws i cws i 1 add get -4 bitshift 15 and cws i get or put
        } for
        cws ncws 1 sub cws ncws 1 sub get 15 and 4 bitshift put
    } if

    % Create the bitmap
    /pixs [ size size mul {-1} repeat ] def
    /qmv {size mul add} bind def
    
    % Finder patterns
    /fpat [
        [ 1 1 1 1 1 1 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 1 1 1 0 1 0 ]
        [ 1 0 0 0 0 0 1 0 ]
        [ 1 1 1 1 1 1 1 0 ]
        [ 0 0 0 0 0 0 0 0 ]
    ] def
    0 1 fpat length 1 sub {
      /y exch def
      0 1 fpat 0 get length 1 sub {
        /x exch def
        /fpb fpat y get x get def
        pixs x y qmv fpb put
        format (full) eq {
            pixs size x sub 1 sub y qmv fpb put
            pixs x size y sub 1 sub qmv fpb put
        } if
      } for
    } for
    
    % Alignment patterns
    /algnpat [
        [ 1 1 1 1 1 ]
        [ 1 0 0 0 1 ]
        [ 1 0 1 0 1 ]
        [ 1 0 0 0 1 ]
        [ 1 1 1 1 1 ]
    ] def
    /putalgnpat {
        /py exch def
        /px exch def
        0 1 4 {
            /pb exch def
            0 1 4 {
                /pa exch def
                pixs px pa add py pb add qmv algnpat pb get pa get put
            } for
        } for
    } bind def
    asp2 2 sub asp3 asp2 sub size 13 sub {
        /i exch def
        i 4 putalgnpat
        4 i putalgnpat
    } for
    asp2 2 sub asp3 asp2 sub size 9 sub { 
        /x exch def
        asp2 2 sub asp3 asp2 sub size 9 sub {
            /y exch def
            x y putalgnpat
        } for
    } for
    
    % Timing patterns
    format (full) eq {
        8 1 size 9 sub {
            /i exch def
            pixs i 6 qmv i 1 add 2 mod put
            pixs 6 i qmv i 1 add 2 mod put
        } for
    } {
        8 1 size 1 sub {
            /i exch def
            pixs i 0 qmv i 1 add 2 mod put
            pixs 0 i qmv i 1 add 2 mod put
        } for
    } ifelse
    
    % Format information modules
    format (full) eq {
        /formatmap [
            [ [ 0 8 ] [ 8 size 1 sub ] ]  [ [ 1 8 ] [ 8 size 2 sub ] ]  [ [ 2 8 ] [ 8 size 3 sub ] ]
            [ [ 3 8 ] [ 8 size 4 sub ] ]  [ [ 4 8 ] [ 8 size 5 sub ] ]  [ [ 5 8 ] [ 8 size 6 sub ] ]
            [ [ 7 8 ] [ 8 size 7 sub ] ]  [ [ 8 8 ] [ size 8 sub 8 ] ]  [ [ 8 7 ] [ size 7 sub 8 ] ]
            [ [ 8 5 ] [ size 6 sub 8 ] ]  [ [ 8 4 ] [ size 5 sub 8 ] ]  [ [ 8 3 ] [ size 4 sub 8 ] ]
            [ [ 8 2 ] [ size 3 sub 8 ] ]  [ [ 8 1 ] [ size 2 sub 8 ] ]  [ [ 8 0 ] [ size 1 sub 8 ] ]
        ] def
    } {
        /formatmap [
            [ [ 1 8 ] ]  [ [ 2 8 ] ]  [ [ 3 8 ] ]  [ [ 4 8 ] ]  [ [ 5 8 ] ]
            [ [ 6 8 ] ]  [ [ 7 8 ] ]  [ [ 8 8 ] ]  [ [ 8 7 ] ]  [ [ 8 6 ] ]
            [ [ 8 5 ] ]  [ [ 8 4 ] ]  [ [ 8 3 ] ]  [ [ 8 2 ] ]  [ [ 8 1 ] ]
        ] def
    } ifelse
    formatmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall
    
    % Version information modules
    size 45 ge {
        /versionmap [
            [ [ size  9 sub 5 ] [ 5 size  9 sub ] ]  [ [ size 10 sub 5 ] [ 5 size 10 sub ] ]
            [ [ size 11 sub 5 ] [ 5 size 11 sub ] ]  [ [ size  9 sub 4 ] [ 4 size  9 sub ] ]
            [ [ size 10 sub 4 ] [ 4 size 10 sub ] ]  [ [ size 11 sub 4 ] [ 4 size 11 sub ] ]
            [ [ size  9 sub 3 ] [ 3 size  9 sub ] ]  [ [ size 10 sub 3 ] [ 3 size 10 sub ] ]
            [ [ size 11 sub 3 ] [ 3 size 11 sub ] ]  [ [ size  9 sub 2 ] [ 2 size  9 sub ] ]
            [ [ size 10 sub 2 ] [ 2 size 10 sub ] ]  [ [ size 11 sub 2 ] [ 2 size 11 sub ] ]
            [ [ size  9 sub 1 ] [ 1 size  9 sub ] ]  [ [ size 10 sub 1 ] [ 1 size 10 sub ] ]
            [ [ size 11 sub 1 ] [ 1 size 11 sub ] ]  [ [ size  9 sub 0 ] [ 0 size  9 sub ] ]
            [ [ size 10 sub 0 ] [ 0 size 10 sub ] ]  [ [ size 11 sub 0 ] [ 0 size 11 sub ] ]
        ] def
    } {
        /versionmap [] def
    } ifelse
    versionmap {
        { {} forall qmv pixs exch 0 put } forall
    } forall
    
    % Solitary dark module in full symbols
    format (full) eq {
        pixs 8 size 8 sub qmv 1 put
    } if
    
    % Calculate the mask patterns
    format (full) eq {
        /maskfuncs [ 
            {add 2 mod} bind
            {exch pop 2 mod} bind
            {pop 3 mod} bind
            {add 3 mod} bind
            {2 idiv exch 3 idiv add 2 mod} bind
            {mul dup 2 mod exch 3 mod add} bind
            {mul dup 2 mod exch 3 mod add 2 mod} bind
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind
        ] def
    } {
        /maskfuncs [ 
            {exch pop 2 mod} bind
            {2 idiv exch 3 idiv add 2 mod} bind
            {mul dup 2 mod exch 3 mod add 2 mod} bind
            {2 copy mul 3 mod 3 1 roll add 2 mod add 2 mod} bind
        ] def
    } ifelse
    /masks maskfuncs length array def
    0 1 masks length 1 sub {
        /m exch def
        /mask size size mul array def
        0 1 size 1 sub {
            /j exch def
            0 1 size 1 sub {
                /i exch def
                i j maskfuncs m get exec 0 eq 
                pixs i j qmv get -1 eq and {1} {0} ifelse
                mask i j qmv 3 -1 roll put
            } for
        } for
        masks m mask put
    } for
    
    % Walk the symbol placing the bitstream
    /posx size 1 sub def
    /posy size 1 sub def
    /dir -1 def  % -1 is upwards, 1 is downwards
    /col 1 def   % 0 is left bit, 1 is right bit
    /num 0 def
    { % loop
        posx 0 lt {exit} if
        pixs posx posy qmv get -1 eq {
            cws num 8 idiv get 7 num 8 mod sub neg bitshift 1 and
            pixs posx posy qmv 3 -1 roll put
            /num num 1 add def
        } if
        col 1 eq {
            /col 0 def
            /posx posx 1 sub def
        } {
            /col 1 def
            /posx posx 1 add def 
            /posy posy dir add def
            posy 0 lt posy size ge or {  % Turn around at top and bottom
                /dir dir -1 mul def
                /posy posy dir add def
                /posx posx 2 sub def
                % Hop over the timing pattern in full size symbols
                format (full) eq posx 6 eq and {/posx posx 1 sub def} if
            } if
        } ifelse
    } loop

    % Evaluate runlength encoded rows or columns in full symbols
    /evalfulln1n3 {
        /scrle exch def
        % Detect runs of 5 or more like modules
        /scr1 0 scrle { dup 5 ge {add 2 sub dup} if pop } forall def
        % Detect 1:1:3:1:1 ratio next to 4 modules of whitespace
        /scr3 0 def
        3 2 scrle length 3 sub {  % Scan odd (dark) runs within bounds
            /j exch def
            scrle j get 3 mod 0 eq {  % Multiple of 3 black modules
                /fact scrle j get 3 idiv def
                scrle j 2 sub 5 getinterval {fact eq} forall and exch pop and and {
                    j 3 eq j 4 add scrle length ge or {  % At either extent of run
                        /scr3 scr3 40 add def
                    } {  % Bounded by dark modules
                        scrle j 3 sub get 4 ge scrle j 3 add get 4 ge or {
                            /scr3 scr3 40 add def
                        } if
                    } ifelse
                } if
            } if
        } for
        scr1 scr3
    } bind def
    
    % Evaluation algorithm for full symbols
    /evalfull {
        /sym exch def

        /n1 0 def /n2 0 def /n3 0 def
        /rle size 1 add array def
        /lastpairs size array def
        /thispairs size array def
        /sizeadd1 size 1 add def
        0 1 size 1 sub {  
            /i exch def

            % Runlength encode (light, dark, light, ...) and evaluate each column
            mark 0 0
            i size dup dup mul 1 sub {
                sym exch get exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } for
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Runlength encode (light, dark, light, ...) and evaluate each row
            /symrow sym i size mul size getinterval def
            mark 0 0 
            symrow { 
                exch 1 index eq {exch 1 add exch} {1 exch} ifelse
            } forall 
            pop
            rle 0 counttomark 2 sub getinterval astore
            evalfulln1n3 n3 add /n3 exch def n1 add /n1 exch def
            pop

            % Count and score same coloured blocks
            /lastpairs thispairs /thispairs lastpairs def def
            symrow 0 get 1 eq {0} {1} ifelse
            symrow {exch 1 index add exch} forall
            pop
            thispairs astore pop
            i 0 gt {
                mark
                lastpairs aload pop thispairs aload pop
                n2 size { exch sizeadd1 index add 3 and 0 eq {3 add} if } repeat
                /n2 exch def
                cleartomark
            } if

        } for
 
        % Score dark/light imbalance 
        /dark 0 sym {add} forall def
        /n4 dark 100 mul size dup mul div 50 sub abs 5 div cvi 10 mul def

        n1 n2 add n3 add n4 add
    } bind def
 
    % Evaluation algorithm for micro symbols
    /evalmicro {
        /sym exch def
        /dkrhs 0 def /dkbot 0 def
        1 1 size 1 sub {
            /i exch def
            /dkrhs dkrhs sym size 1 sub i qmv get add def
            /dkbot dkbot sym i size 1 sub qmv get add def
        } for
        dkrhs dkbot le {
            dkrhs 16 mul dkbot add neg
        } {
            dkbot 16 mul dkrhs add neg
        } ifelse
    } bind def
    
    % Evaluate the masked symbols to find the most suitable
    /bestscore 999999999 def
    0 1 masks length 1 sub {
        /m exch def
        /masksym size size mul array def
        0 1 size size mul 1 sub {
            /i exch def
            masksym i pixs i get masks m get i get xor put
        } for
        format (full) eq {
            masksym evalfull /score exch def
        } {
            masksym evalmicro /score exch def
        } ifelse
        score bestscore lt { 
            /bestsym masksym def
            /bestmaskval m def
            /bestscore score def
        } if    
    } for
    /pixs bestsym def
    
    % Add the format information
    format (full) eq {
        /fmtvals [
            16#5412 16#5125 16#5e7c 16#5b4b 16#45f9 16#40ce 16#4f97 16#4aa0 
            16#77c4 16#72f3 16#7daa 16#789d 16#662f 16#6318 16#6c41 16#6976
            16#1689 16#13be 16#1ce7 16#19d0 16#0762 16#0255 16#0d0c 16#083b 
            16#355f 16#3068 16#3f31 16#3a06 16#24b4 16#2183 16#2eda 16#2bed
        ] def
        /ecid (MLHQ) eclevel search pop length exch pop exch pop def
        /fmtval fmtvals ecid 3 bitshift bestmaskval add get def
    } {
        /fmtvals [
            16#4445 16#4172 16#4e2b 16#4b1c 16#55ae 16#5099 16#5fc0 16#5af7
            16#6793 16#62a4 16#6dfd 16#68ca 16#7678 16#734f 16#7c16 16#7921
            16#06de 16#03e9 16#0cb0 16#0987 16#1735 16#1202 16#1d5b 16#186c
            16#2508 16#203f 16#2f66 16#2a51 16#34e3 16#31d4 16#3e8d 16#3bba
        ] def
        /symid [ [0] [1 2] [3 4] [5 6 7] ] size 11 sub 2 idiv get eclval get def
        /fmtval fmtvals symid 2 bitshift bestmaskval add get def
    } ifelse
    0 1 formatmap length 1 sub {
        /i exch def
        formatmap i get {
            pixs exch {} forall qmv fmtval 14 i sub neg bitshift 1 and put
        } forall
    } for
    
    % Add the version information
    size 45 ge {
        /vervals [
            16#07c94 16#085bc 16#09a99 16#0a4d3 16#0bbf6 16#0c762 16#0d847 
            16#0e60d 16#0f928 16#10b78 16#1145d 16#12a17 16#13532 16#149a6 
            16#15683 16#168c9 16#177ec 16#18ec4 16#191e1 16#1afab 16#1b08e 
            16#1cc1a 16#1d33f 16#1ed75 16#1f250 16#209d5 16#216fd 16#228ba 
            16#2379f 16#24b0b 16#2542e 16#26a64 16#27541 16#28c69
        ] def
        /verval vervals size 17 sub 4 idiv 7 sub get def
        0 1 versionmap length 1 sub {
            /i exch def
            versionmap i get {
                pixs exch {} forall qmv verval 17 i sub neg bitshift 1 and put
            } forall
        } for
    } if

    % Return the arguments
    <<
    /ren //renmatrix
    /pixs pixs
    /pixx size
    /pixy size
    /height size 2 mul 72 div
    /width size 2 mul 72 div
    /opt options
    >>

    dontdraw not //renmatrix if

    end

} bind def
/qrcode dup load /uk.co.terryburton.bwipp defineresource pop
end
/setpacking where {pop setpacking} if

3 3 scale

120 125 moveto (123456789012345678901234) (format=micro) /qrcode /uk.co.terryburton.bwipp findresource exec

