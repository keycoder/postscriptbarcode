%!PS

% State key: "U"pper, "L"ower, "M"ixed, "P"unctuation, "D"igit, "B"inary

% Special function characters
/lu -1 def  /ll -2 def  /lm -3 def
/lp -4 def  /ld -5 def  /su -6 def
/sp -7 def  /sb -8 def  /fl -9 def

% Character maps for each state
/charmaps [
  %  U    L    M    P    D
  [  sp   sp   sp   fl   sp ]  % 0
  [  32   32   32   13   32 ]  % 1
  [ (A)  (a)    1  -99  (0) ]  % 2
  [ (B)  (b)    2  -99  (1) ]  % 3
  [ (C)  (c)    3  -99  (2) ]  % 4
  [ (D)  (d)    4  -99  (3) ]  % 5
  [ (E)  (e)    5  (!)  (4) ]  % 6
  [ (F)  (f)    6  (")  (5) ]  % 7
  [ (G)  (g)    7  (#)  (6) ]  % 8
  [ (H)  (h)    8  ($)  (7) ]  % 9
  [ (I)  (i)    9  (%)  (8) ]  % 10
  [ (J)  (j)   10  (&)  (9) ]  % 11
  [ (K)  (k)   11  (')  (,) ]  % 12
  [ (L)  (l)   12   40  (.) ]  % 13
  [ (M)  (m)   13   41   lu ]  % 14
  [ (N)  (n)   27  (*)   su ]  % 15
  [ (O)  (o)   28  (+)  -99 ]  % 16
  [ (P)  (p)   29  (,)  -99 ]  % 17
  [ (Q)  (q)   30  (-)  -99 ]  % 18
  [ (R)  (r)   31  (.)  -99 ]  % 19
  [ (S)  (s)  (@)  (/)  -99 ]  % 20
  [ (T)  (t)   92  (:)  -99 ]  % 21
  [ (U)  (u)  (^)  (;)  -99 ]  % 22
  [ (V)  (v)  (_)  (<)  -99 ]  % 23
  [ (W)  (w)  (`)  (=)  -99 ]  % 24
  [ (X)  (x)  (|)  (>)  -99 ]  % 25
  [ (Y)  (y)  (~)  (?)  -99 ]  % 26
  [ (Z)  (z)  127  ([)  -99 ]  % 27
  [  ll   su   ll  (])  -99 ]  % 28
  [  lm   lm   lu  ({)  -99 ]  % 29
  [  ld   ld   lp  (})  -99 ]  % 30
  [  sb   sb   sb   lu  -99 ]  % 31
] def 

% Invert charmaps to give character to value maps for each state
/charvals [ 32 dict 32 dict 32 dict 32 dict 16 dict ] def
0 1 charmaps length 1 sub {
  /i exch def
  /encs charmaps i get def
  0 1 4 {
    /j exch def
    encs j get dup type /stringtype eq {0 get} if  % convert string to ASCII if required
    charvals j get exch i put 
  } for
} for

% Encoding functions
/encu {
  /charval exch charvals 0 get exch get def
  [ 4 {0} repeat charval 2 5 string cvrs {48 sub} forall ] dup length 5 sub 5 getinterval
} bind def
/encl {
  /charval exch charvals 1 get exch get def
  [ 4 {0} repeat charval 2 5 string cvrs {48 sub} forall ] dup length 5 sub 5 getinterval
} bind def
/encm {
  /charval exch charvals 2 get exch get def
  [ 4 {0} repeat charval 2 5 string cvrs {48 sub} forall ] dup length 5 sub 5 getinterval
} bind def
/encp {
  /charval exch charvals 3 get exch get def
  [ 4 {0} repeat charval 2 5 string cvrs {48 sub} forall ] dup length 5 sub 5 getinterval
} bind def
/encd {
  /charval exch charvals 4 get exch get def
  [ 3 {0} repeat charval 2 4 string cvrs {48 sub} forall ] dup length 4 sub 4 getinterval
} bind def
/encb {
  pop
  [0 0 0 0 0 0 0 0]
} bind def
/encfuncs [ /encu /encl /encm /encp /encd /encb ] def

/input [ 34 54 23 67 ] def

/e 10000 def  % "Empty"

/latlen [  % Bit length of latch between modes
% To:  U  L  M  P  D  B      From
    [  0  5  5 10  5 10 ]  % U
    [ 10  0  5 10  5 10 ]  % L
    [  5  5  0  5 10 10 ]  % M
    [  5 10 10  0 10 15 ]  % P
    [  4  9  9 14  0 14 ]  % D
    [  0  0  0  0  0  0 ]  % B
] def

/shftlen [  % Bit length of shift to mode
% To:  U  L  M  P  D      From
    [  e  e  e  5  e ]  % U
    [  5  e  e  5  e ]  % L
    [  e  e  e  5  e ]  % M
    [  e  e  e  e  e ]  % P
    [  4  e  e  4  e ]  % D
] def

%           U L M P D B
/charsize [ 5 5 5 5 4 8 ] def

%          U  L  M  P  D  B
/curlen [  0  e  e  e  e  e ] def
/curseq [ [] [] [] [] [] [] ] def

/backto 0 def  % U

/latches [ lu  ll  lm  lp  ld -99 ] def
/shifts  [ su -99 -99  sp -99  sb ] def

input {

  /char exch def

  % Check for optimisations in the current sequences
  0 1 5 {
    /x exch def
    0 1 5 {   
      /y exch def
      curlen x get latlen x get y get add curlen y get lt {
        charvals x get latches y get known {  % Latch must exist
	% Wrong - latch can be composite!
          curlen y curlen x get latlen x get y get add put
          curseq y [ 
            curseq x get {} forall
            latches y get encfuncs x get load exec {} forall 
          ] put  % TODO
        } if
      } if
    } for
  } for

dddd

  % Determine optimal next sequences for each valid encoding 
  /nxtlen [ e e e e e e ] def 
  /nxtseq [] def
  0 1 5 {
    /x exch def

    { % loop for common exit

      /encchar char encfuncs x get load exec def 
      encchar length 0 eq {exit} if  % No valid encoding in this state

      % Extend directly
      curlen x get charsize x get add nxtlen x get lt {
        nxtlen x curlen x get charsize x get add put
        nxtseq x [ curseq x get {} forall encchar {} forall ] put  % TODO
      } if

      % Optimise the next sequences for direct shifts 
      0 1 5 {
        /y exch def
        x y ne {
          curlen y get shftlen y get x get add charsize x get add nxtlen y get lt {
            nxtlen y curlen y get shftlen y get x get add charsize x get add put
            nxtseq y [ curseq y get {} forall shiftToX {} forall ] put  % TODO
          } if
        } if
      } for

      exit
    } loop

  } for

  % Optimise next sequences using punctuation compression

  % Binary padding


  /curlens nxtlens def
  /curseq nxtseq def

} forall

asdf

